#!/bin/bash

# **********************************************************************
# Preamble

function absolute_path {
    (cd "$(dirname "$1")" && pwd)
}

function print_title {
    cat <<EOF
PETRINIZER: The checker for Petri Nets
[$1]
EOF
}

function print_usage {
    cat <<EOF

Usage: $0 [options] input_file
Option list:
 -h | --h | -help | --help    : Prints this help
 -v                           : Verbose output

EOF
}

function vecho {
    if [ -n "$verbose" ]; then
        echo "$1"
    fi
}


# **********************************************************************
# Entry point

print_title "$*"


# parse parameters
for a in $@; do
    case $a in
        h | --h | -help | --help)
            print_usage
            exit 0
            ;;
        -v | --v)
            verbose=true
            ;;
        -*)
            echo 'ERROR: Unknown option '$a
            exit 3
            ;;
        *)
            input=$a
    esac
done

if [ -z $input ]; then
    echo 'ERROR: No input file was given'
    exit 3
fi

if [ ! -e $input ]; then
    echo "ERROR: The file $input does not exist"
    exit 3
fi

sysdir=$(absolute_path $0)

tmpdir=/tmp/pnerf-$(date +%s%N)
mkdir $tmpdir

set -e
set -o pipefail

function exit_with {
  result=$1
  echo
  echo '-------------------------------------------'
  if $invariant; then
    if [[ $result -eq 0 ]]; then
      echo "Invariant I for the petri net:"
      cat $tmpdir/invariant.smt2
    else
      echo 'No invariant found for the net'
    fi
  else
    if [[ $result -eq 0 ]]; then
      echo 'The petri net satisfies the property!'
    else
      echo 'The petri net may not satisfy the property'
    fi
  fi
  echo '-------------------------------------------'
  echo
  echo
  set +o pipefail
  set +e
  rm -r $tmpdir
  exit $result
}

function run_z3 {
  z3_input=$1
  z3_output=$2
  if [ -z "$verbose" ]; then
    z3 -smt2 $z3_input 2>/dev/null >$z3_output
    res=$?
  else
    z3 -smt2 $z3_input 2>/dev/null | tee $z3_output
    res=$?
  fi
  return $res
}

function run_sicstus {
  prolog_file=$1
  pl_output=$2
  pl_input=${@:3}
  if [ -z "$verbose" ]; then
    sicstus -l "$sysdir"/$prolog_file -- $pl_input 2>/dev/null >$pl_output
    res=$?
  else
    sicstus -l "$sysdir"/$prolog_file -- $pl_input 2>/dev/null | tee $pl_output
    res=$?
  fi
  return $res
}

function run_bash {
  bash_file=$1
  bash_output=$2
  bash_input=${@:3}
  if [ -z "$verbose" ]; then
    $bash_file $bash_input >$bash_output
    res=$?
  else
    $bash_file $bash_input | tee $bash_output
    res=$?
  fi
  return $res
}

#invariant=false
invariant=true

#refinement_methods=( 'trap' 'empty-trap' 'subnet-trap' )
#refinement_methods=( 'trap' 'empty-trap' )
#refinement_methods=( 'subnet-trap' )
#refinement_methods=( )
refinement_methods=( 'trap' )
#equation_type='Int'
equation_type='Real'

cp $(absolute_path $input)/$(basename $input) $tmpdir/input-petri-net.pl

function minimize_invariant {
  vecho
  vecho "* Constructing constraints C'_0 for petri net N"
  run_sicstus petri-net-to-prime-constraints.pl $tmpdir/constraints-c-prime.smt2 $tmpdir/pp-petri-net.pl

  vecho
  vecho "* Checking SAT(C'_$iter)"
  if ( run_z3 $tmpdir/constraints-c-prime.smt2 $tmpdir/model-a-prime.smt2 ); then
    vecho "- sat, getting model A'_$iter for C'_$iter"
    >$tmpdir/minimization-constraints.pl
    run_bash "$sysdir"/smt2-model-to-prolog-model.sh $tmpdir/model-a-prime.pl $tmpdir/model-a-prime.smt2 
    iter=0
    while (
      vecho
      vecho " * Minimizing invariant in iteration $iter"
      vecho " - finding next place to be set to zero"
      run_sicstus minimization-constraints.pl $tmpdir/minimization-constraints-next.pl $tmpdir/pp-petri-net.pl $tmpdir/model-a-prime.pl $tmpdir/minimization-constraints.pl
      ); do
      vecho " - constructing additional z3 constraints"
      run_sicstus minimization-constraints-to-z3 $tmpdir/constraints-c-prime-plus.smt2 $tmpdir/pp-petri-net.pl $tmpdir/model-a-prime.pl $tmpdir/minimization-constraints-next.pl
      vecho " - constructing complete z3 constraints"
      run_bash "$sysdir"/succ-constraints.sh $tmpdir/constraints-c-prime-next.smt2 $tmpdir/constraints-c-prime.smt2 $tmpdir/constraints-c-prime-plus.smt2
      vecho " - testing sat"
      if ( run_z3 $tmpdir/constraints-c-prime-next.smt2 $tmpdir/model-a-prime.smt2 ); then
        vecho " - sat, using new model"
        run_bash "$sysdir"/smt2-model-to-prolog-model.sh $tmpdir/model-a-prime.pl $tmpdir/model-a-prime.smt2 
      else
        vecho " - unsat, disabling used place"
        cat $tmpdir/minimization-constraints-next.pl >>$tmpdir/minimization-constraints.pl
      fi
      iter=$((iter + 1))
    done
    vecho " - no more places to be set to zero"
    vecho " - constructing invariant I for petri net N and model A'_$iter"
    run_sicstus y-invariant.pl $tmpdir/y-invariant.smt2 $tmpdir/pp-petri-net.pl $tmpdir/model-a-prime.pl
    cat $tmpdir/y-invariant.smt2 >>$tmpdir/invariant.smt2
    return 0
  else
    vecho " - unsat"
    return 2
  fi
}

function construct_invariant {
  target=1
  while (
    vecho
    vecho "* Constructing petri net N with target $target from input file"
    run_sicstus input-file-to-petri-net.pl $tmpdir/pp-petri-net.pl $target $tmpdir/input-petri-net.pl
  ); do 
    if ( ! minimize_invariant ); then
      exit_with 2 $invariant
    fi
    target=$((target + 1))
  done
  exit_with 0 $invariant
}

if [[ ${#refinement_methods[@]} -eq 0 && $invariant ]]; then
  construct_invariant
else

  vecho
  vecho '* Constructing petri net N from input file'
  run_sicstus input-file-to-petri-net.pl $tmpdir/pp-petri-net.pl 0 $tmpdir/input-petri-net.pl

  vecho
  vecho '* Constructing constraints C_0 for petri net N'
  run_sicstus petri-net-to-constraints.pl $tmpdir/constraints-c.smt2 $equation_type $tmpdir/pp-petri-net.pl

  method_count=${#refinement_methods[@]}
  iter=0
  while
    (
      vecho
      vecho "* Iteration $iter"
      vecho
      vecho "* Checking SAT(C_$iter)"
      run_z3 $tmpdir/constraints-c.smt2 $tmpdir/model-a.smt2
    ); do
      vecho
      vecho "- sat, getting model A for C_$iter"
      run_bash "$sysdir"/smt2-model-to-prolog-model.sh $tmpdir/model-a.pl $tmpdir/model-a.smt2 

      method_index=0
      while [[ $method_index -lt $method_count ]]; do
          method=${refinement_methods[$method_index]}
          vecho
          vecho "* Applying refinement method '$method'"

          vecho "- constructing $method constraints C_theta for petri net N and model A"
          run_sicstus refinement-methods/$method-constraints.pl $tmpdir/constraints-ctheta.smt2 $tmpdir/pp-petri-net.pl $tmpdir/model-a.pl
          vecho '- checking SAT(C_theta)'
          if ( run_z3 $tmpdir/constraints-ctheta.smt2 $tmpdir/model-atheta.smt2 ); then
              vecho "- sat, getting model A_theta for C_theta"
              run_bash "$sysdir"/smt2-model-to-prolog-model.sh $tmpdir/model-atheta.pl $tmpdir/model-atheta.smt2 

              vecho "- constructing $method constraint delta for petri net N and model A_theta"
              run_sicstus refinement-methods/$method-delta-constraint.pl $tmpdir/constraint-delta.smt2 $tmpdir/pp-petri-net.pl $tmpdir/model-atheta.pl
              if $invarant; then
                run_sicstus refinement-methods/$method-prolog-delta-constraint.pl $tmpdir/constraint-delta.pl $((iter + 1)) $tmpdir/pp-petri-net.pl $tmpdir/model-atheta.pl
                cat $tmpdir/constraint-delta.smt2 >> $tmpdir/invariant.smt2
                cat $tmpdir/constraint-delta.pl >> $tmpdir/input-petri-net.pl
              fi

              vecho "- constructing constraints C_$((iter+1)) for C_$iter and delta"
              run_bash "$sysdir"/succ-constraints.sh $tmpdir/constraints-cn.smt2 $tmpdir/constraints-c.smt2 $tmpdir/constraint-delta.smt2
              mv $tmpdir/constraints-cn.smt2 $tmpdir/constraints-c.smt2
              break
          else
              vecho " - unsat"
              method_index=$((method_index+1))
          fi
          vecho
      done
      if [[ $method_index -ge $method_count ]]; then
          exit_with 2 $invariant
      fi
      iter=$((iter+1))
  done
  vecho " - unsat"

  if $invarant; then
    construct_invariant
  else
    exit_with 0 $invariant
  fi

fi
