\documentclass{llncs}

\newcommand{\isDraft}{true}

\input{preamble}

\ifthenelse{\equal{\isDraft}{true}}{
  \usepackage[a4paper, top=2cm, bottom=3cm, left=2cm, right=2cm]{geometry}
  \pagestyle{plain}
}{}

\begin{document}

\nocite{DOsualdoSAS13}

\ifthenelse{\equal{\isDraft}{false}}{
  \title{An SMT-based Approach to Coverability Analysis}
  \author{
    Javier Esparza\inst{1}
    \and
    Rupak Majumdar\inst{2}
    \and
    Philipp Meyer\inst{1}
    \and
    Filip Niksic\inst{2}
    \and
    Rusl\'{a}n Ledesma-Garza\inst{1}
  }
  \institute{
    Technische Universit\"at M\"unchen
    \and
    MPI-SWS, Kaiserslautern and Saarbr\"ucken
  }
  
  \maketitle

  \begin{abstract}
    Model checkers based on Petri net coverability have been used
    successfully in recent years to verify safety properties of concurrent
    shared-memory or asynchronous message-passing software. The bottleneck
    in the verification process is the iterative computation of the
    (backward) reachable or (forward) coverable set, and most recent
    research has focused on non-trivial heuristics to speed it up.

    In this paper, we revisit a constraint approach to the problem based on
    classical Petri net analysis techniques: marking equation, place
    invariants, and traps. Given a marking M to be covered, the approach
    constructs constraints corresponding to increasingly precise
    overapproximations of the reachable markings covering M. If one of
    these constraints is unsatisfiable, then M is not coverable.

    Previous work on this approach suffered from the absence of efficient
    decision procedures for linear arithmetic, which nowadays exist as a
    part of SMT solvers. We show how to utilize an SMT solver to implement
    the constraint approach, and additionally, to generate a minimized
    inductive invariant from a safety proof.

    We empirically evaluate our procedure on a large set of existing Petri
    net benchmarks arising out of software verification. Surprisingly, even
    though our technique is incomplete, we show that it can quickly
    discharge all safe instances, usually competitive with, and occasionally
    much faster than, state-of-the-art techniques. Additionally, the
    inductive invariants computed are usually orders of magnitude smaller
    than those produced by existing solvers.
  \end{abstract}
}{
}


\input{sec_introduction}
\input{sec_illustration}
\input{sec_preliminaries}

\newpage
\section{Method Safety}

The method Safety checks that a given Petri net \verb=N= never violates a property \verb=P=.
We present the method Safety by example on Lamport's 1-bit algorithm [Esparza1997].

\begin{verbatim}
* Method Safety:

  Subprocedure \mathcal{C} constructs state constraints C corresponding to N.
\end{verbatim}

\input{fig_dia_method_safety}

\input{fig_method_safety}

\begin{verbatim}
* Property of state constraints C: If C U {\neg P} is unsat then N |= P.

* Place equation:
  
  For a given place s the place equation is

  # of tokens in s = initial number of tokens of place s
                     + # times each input transition of s fires
                     - # times each output transition of s fires

* Non-negativity conditions:

  # of tokens in place s           >= 0
  # of times transition t is fired >= 0

* Subprocedure \mathcal{C}:

  Input:
    (S, T, E, M0) : Petri net
  Output:
    C : State constraints

  Pseudocode:

\end{verbatim}

\begin{align*}
  C(S, T, E, M_0) :=& \left( \bigwedge_{s \in S} \left(
    s = M_0(s) + \sum_{(t, s) \in E} t - \sum_{(s, t) \in E} t
  \right) \right) \land
    \left( \bigwedge_{s \in S} s \ge 0 \right) \land
    \left( \bigwedge_{t \in T} t \ge 0 \right)
\end{align*}

\newpage

\begin{verbatim}
* Example

  - Code:

  Process 1:                     |      Process 2:
                                 |
      bit1 := false              |      bit2 := false
      while true do              |      while true do
  p1:   bit1 := true             |  q1:   bit2 := true
  p2:   while bit2 do skip od    |  q2:   if bit1 then
  p3:   <critical section>       |  q3:     bit2 := true
        bit1 := false            |  q4:     while bit1 do skip od
      od                         |          goto q1
                                 |        fi
                                 |  q5:   <critical section>
                                 |        bit2 := false
                                 |      od

  - Property 1: Process 1 and Process 2 are never in their respective critical section at the same time.

  - Property 1: p3 + q5 <= 1

  - Property 2: Process 1 is in at most one state at a time

  - Property 2: p1 + p2 + p3 <= 1

  - Petri net:

\end{verbatim}

\input{fig_lamport_net}

\newpage

\begin{verbatim}
  - State constraints C:

    Place equations:
  


    p1    = 1 - s1      + s3
    ^       ^   ^         ^
    |       |   |         |
    |       |   |         |
    |       |   |         |
    |       |   |        # of tokens given to p1
    |       |   |    
    |       |  # of tokens taken from p1
    |       |
    |      initial number of tokens in p1
    |
    number of tokens in p1

    p2    = 0 + s1 - s2
    p3    = 0      + s2 - s3
    bit1  = 0 + s1      - s3
    nbit1 = 1 - s1      + s3
    q1    = 1 +              - t1           + t4      + t6
    q2    = 0 +              + t1 - t2           - t5
    q3    = 0 +                   + t2 - t3
    q4    = 0 +                        + t3 - t4
    q5    = 0 +                                  + t5 - t6
    nbit2 = 1 +              - t1      + t3           + t6
    
    Non-negativity conditions:
  
    p1    >= 0
    p2    >= 0
    p3    >= 0
    bit1  >= 0
    nbit1 >= 0
    q1    >= 0
    q2    >= 0
    q3    >= 0
    q4    >= 0
    q5    >= 0
    nbit2 >= 0

  - Using property 2
  
  - Negated property 2 \neg P:

    p1 + p2 + p3 >= 2
\end{verbatim}

\newpage

\section{Method Safety by Refinement}

The method Safety by Refinement applies trap conditions to check that a given Petri net \verb=N= never violates a property \verb=P=.

\begin{verbatim}
* Method Safety by Refinement:

  Subprocedure TrapConditions constructs trap conditions C_\theta corresponding to N and A.
  Subprocedure \Delta constructs refinement constraint \delta corresponding to A_\theta.
\end{verbatim}

\input{fig_dia_method_safety_by_refinement}

\input{fig_method_safety_by_refinement}

\begin{verbatim}
* Property of trap conditions C_\theta: If C_\theta is sat then there is a set S such that
  1. S is a trap in the net N
  2. S is marked in the initial marking M0
  3. S is unmarked in the assignment A

* Property of A_\theta: for each place s, A_\theta(s) iff s \in S

* Property of refinement constraint \delta: Constraint \delta refines the abstraction, i.e.
  1. A ^ \delta is unsat (\delta excludes A)
  2. N |= \delta is sat  (\delta is a property of N)
\end{verbatim}

\newpage

\begin{verbatim}
* Subprocedure TrapConditions:

  Input:
    (S, T, E, M0) : Petri net
    A             : Satisfying assignment for C \cup { ~P }
  Output:
    C_\theta      : Trap conditions

  Pseudocode:
  
\end{verbatim}
\begin{align*}
  C_\theta(S, T, E, M_0) :=& \left( \bigwedge_{s \in S} \left( s \Rightarrow
      \bigwedge_{(s, t) \in E} \bigvee_{(t, p) \in E} p
    \right) \right) \land
    \left( \bigvee_{s \in S: M_0(s) > 0} s \right) \land
    \left( \bigwedge_{s \in S: A(s) > 0} \neg s \right)
\end{align*}
\begin{verbatim}

* Subprocedure \Delta:

  Input:
    A_\theta      : Satisfying assignment for C_\theta
  Output:
    \delta        : Refinement constraint \delta

  Pseudocode:

\end{verbatim}
\begin{align*}
  & \delta(A_\theta) := \left( \sum_{A_\theta(s)} s \ge 0 \right)
\end{align*}

\newpage

\begin{verbatim}
* Example

  - State constraints C same as in the example for method Safety.
  
  - Using property 1
  
  - Negated property 1 \neg P:

    p3 + q5 >= 2
 
  - Assignment A:
    p1    = 0
    p2    = 0
    p3    = 1
    bit1  = 1
    nbit1 = 0
    q1    = 0
    q2    = 0
    q3    = 0
    q4    = 0
    q5    = 0
    nbit2 = 0

  - Trap conditions C_\theta:

    - Trap implications:
                s1
             ----------
    p1    => p2 \/ bit1
    ^           ^      ^
    |           |      |
    |           |     bit1 \in S
    |           |
    |          p2 \in S
    |
    p1 \in S
    
    p2    => p3 \/ nbit2
    p3    => p1 \/ nbit1
    bit1  => (p1 \/ nbit1) /\ (q3 \/ bit1)
    nbit1 => (p2 \/ bit1) /\ (q1 \/ nbit1) /\ (q5 \/ nbit1)
    q1    => q2
    q2    => (q3 \/ bit1) /\ (q5 \/ nbit1)
    q3    => q4 \/ nbit2
    q4    => q1 \/ nbit1
    q5    => q1 \/ nbit2
    nbit2 => q2 /\ (p3 \/ nbit2)

    - At least one of the initially marked places belongs to S:
    p1 \/ q1 \/ nbit1 \/ nbit2

    - None of the marked places in A belongs to S:
    ~p3 /\ ~q5 /\ ~bit1
  
  - Assignment A_\theta:
    p1    = false
    p2    = true
    p3    = false
    bit1  = false
    nbit1 = true
    q1    = false
    q2    = true
    q3    = true
    q4    = false
    q5    = false
    nbit2 = true

  - Refinement constraint \delta:
    p2 + q3 + q5 + nbit1 + nbit2 >= 1
    ^    ^    ^    ^       ^
    |    |    |    |       |
    ------------------------
      |
      S = {p2, q3, q5, nbit1, nbit2}, therefore \delta excludes
      assignment A in the next iteration
\end{verbatim}

\newpage

\begin{verbatim}

* Trap implication:

  place s \in S =>    /\       \    /
                     /  \       \  /     place p \in S
                    /    \       \/
                   t \in s*   p \in t*   


  "if s is in trap S then for each output transition t at least one successor p is in trap S"


* Refinement constraint \delta:

  \Sigma s >= 1  
  A(s)

  "At least one place in S is always marked"
\end{verbatim}

\newpage

\section{Method Invariant}

The method Invariant constructs an invariant \verb=I= for given Petri
net \verb=N= and \verb=P= when \verb=N= never violates \verb=P=.

\begin{verbatim}
* Code, property, and Petri net: same as in section Method Safety.
\end{verbatim}

\begin{verbatim}
* Method Invariant

  Subprocedure \mathcal{C'} constructs dual state constraints C' corresponding to N and P.
  Subprocedure Model returns assignment A such that A satisfies C'.
  Subprocedure Inv constructs invariant I corresponding to N and A'.
\end{verbatim}

\input{fig_dia_method_invariant}

\input{fig_method_invariant}

\begin{verbatim}
* Property of dual state constraints C':  If C' is sat then N |= P.

* Property of invariant I:
  - I is reachable: For each reachable marking M, I(M) is valid
  - I is safe:      For markings that violate the property, I(M) is unsat
  - I is inductive: For each marking M, if I(M) is valid and M -> M1 then I(M1) is valid
\end{verbatim}

\newpage

\begin{verbatim}
* Subprocedure \mathcal{C'}:

  Input:
    N = (S, T, E, M0)  : Petri net
    \neg P = (p_1,1 + ... + p_1,m_1 >= b_1 /\ p_2,1 + ... + p_2,m_2 >= b_2 /\
              ... /\ p_n,1 + ... + p_n,m_n >= b_n ) : Negated property
  Output:
    C'            : Dual state constraints

Input:
 N      = (S, T, E, M0)
        = ( (a b nbit2 ) (t1 t2) (e1 ... en) (1 0 0) )
\neg P  = ( a + b >= 2 )

Pseudocode:
\end{verbatim}

\begin{align*}
  C'(N, \neg P) =& \left( \bigwedge_{t \in T} \left( 0 \ge
                      \sum_{(t, s) \in E} s
                    - \sum_{(s, t) \in E} s \right) \right) \land
     \left( \sum_{s \in S} M_0(s) \cdot s <
       \sum_{i=1}^n b_i \cdot target_i \right) \land \\
     & \left( \bigwedge_{s \in S} \left ( s \ge 
       \sum_{i : s \in \{ p_{i,1}, \ldots, p_{i,m_i} \} } target_i \right) \right) \land
     \left( \bigwedge_{i=1}^n \left( target_i \ge 0 \right) \right)
\end{align*}

\begin{verbatim}
* Subprocedure Inv:

  Input:
    N = (S, T, E, M0) : Petri net
    A'                : Satisfying assignment for C'

  Output:
    I                 : Invariant

  Pseudocode:
\end{verbatim}

\begin{align*}
  I(N, A') =& \left( \sum_{s \in S} A'(s) \cdot s \le
                     \sum_{s \in S} A'(s) \cdot M_0(s) \right)
\end{align*}

\newpage

\begin{verbatim}
* Derivation of invariant I for Petri net N that satisfies property P:

  M                                    : marking          ~ places
  C                                    : incidence matrix ~ rows correspond to places, columns correspond to transitions, relates places to transitions
  X                                    : firing vector    ~ transitions

  The following constraints C1 are unsat.
  M = M0 + C*X                         : place equations
  M >= 0                               : non-negativity conditions for places
  X >= 0                               : non-negativity conditions for transitions
  AM >= b                              : property P negated

  Substitute M to obtain constraints C2.
  A(M0 + CX) >= b                      : property P negated
  M0 + CX >= 0                         : non-negativity conditions for places
  X >= 0                               : non-negativity conditions for transitions

  Rewrite each system to obtain constraints C3.
  (-A*C)      (A*M0-b)                 : property P negated
  (  -C)*X <= (  M0  )                 : non-negativity conditions for places
  (  -I)      (   0  )                 : non-negativity conditions for transitions

  Apply Farkas' Lemma to obtain constraints C4.
  yT*(-A*C)                            : 
     (  -C) = 0                        : 
     (  -I)                            : 

  yT*(A*M0-b)                          : 
     (  M0  ) < 0                      : 
     (   0  )                          : 

  y >= 0                               : 

  The constraints C4 are sat iff the following constraints C5 are sat.
  y1 * A * C + y2 * C + y3 = 0         : 
  y1 * (A*M - b) + y2 * M0 < 0         : 
  y1 >= 0                              : 
  y2 >= 0                              : 
  y3 >= 0                              : 

  The constraints C5 are sat iff the following constraints C6 are sat.
  (y1 * A + y2) * C  <= 0              : 
  (y1 * A + y2) * M0 < y1 * b          : 
  y1 >= 0                              : 
  y2 >= 0                              : 

  The constraints C6 are sat iff the following constraints C' are sat.
  \lambda * C  <= 0                    : inductivity constraint
  \lambda * M0 < y1 * b                : safety constraint
  \lambda >= y1 * A                    : property constraint
  y1 >= 0                              : non-negativity constraint

  For \lambda satisfying C' the invariant is the following.
  I(M) = (\lambda * M <= \lambda * M0) : invariant
\end{verbatim}

\newpage

\begin{verbatim}
* Example:
  
  - Using property 2

  - Dual state constraints C':

    0 >= - p1 + p2      + bit1 - nbit2
    0 >=      - p2 + p3
    0 >= + p1      - p3 - bit1 + nbit2

    0 >= - q1 + q2                - nbit2
    0 >=      - q2 + q3
    0 >=           - q3 + q4      + nbit2
    0 >= + q1           - q4
    0 >=      - q2           + q5
    0 >= + q1                - q5 + nbit2

    p1 + q1 + nb1 + nb2 < 2 * target_1

    p1    >= target_1
    p2    >= target_1
    p3    >= target_1
    bit1  >= 0
    nbit1 >= 0
    q1    >= 0
    q2    >= 0
    q3    >= 0
    q4    >= 0
    q5    >= 0
    nbit2 >= 0

    target_1 >= 0

  - Model A':

    p1       = 3
    p2       = 2
    p3       = 2
    bit1     = 1
    nbit1    = 0
    q1       = 0
    q2       = 0
    q3       = 0
    q4       = 0
    q5       = 0
    nbit2    = 0
    target_1 = 2
    
  - Invariant:

    3 * p1 + 2 * p2 + 2 * p3 + bit1 <= 3

\end{verbatim}

\newpage

\section{Method Invariant with Minimization}

The method Invariant with Minimization constructs an invariant \verb=I=
that uses a minimal number of places for given Petri net \verb=N= and
\verb=P= when \verb=N= never violates \verb=P=. 

\begin{verbatim}
* Code, property, and Petri net: same as in section Method Safety.

* Method Invariant with Minimization

  Subprocedure \text{MinConstraints} constructs minimization constraints C_M corresponding to N and A'
\end{verbatim}

\input{fig_dia_method_invariant_w_minimization}

\input{fig_method_invariant_w_minimization}

\begin{verbatim}
* Property of minimization constraints C_M generated from A': 
    If A'' satisfies C' u C_M, then Inv(N, A'') uses less places than Inv(N, A')
\end{verbatim}

\newpage

\begin{verbatim}
* Subprocedures \mathcal{C'} and Inv are the same as in Method Invariant

* Subprocedure \text{MinConstraints}:

  Input:
    N = (S, T, E, M0)  : Petri net
    A'                 : Satisfying assignment for C'
  Output:
    C_M                : Minimization Constraints

  Pseudocode:

\end{verbatim}

\begin{align*}
  C_M(N, A') =& \left( \bigwedge_{s \in S} \left(
      (s > 0 \Rightarrow b_s = 1) \land (s = 0 \Rightarrow b_s = 0)
    \right) \right) \land
    \left( \sum_{s \in S} b_s < \sum_{s \in S : A'(s) > 0} 1 \right)
\end{align*}

\newpage

\begin{verbatim}
* Example:

  - Dual state constraints C' and satisfying assignment A' for C' as in example for method Invariant

  - Minimization constraints C_M:

    p1     > 0 => b_p1   = 1
    |            -----------
    |               |
    |            place p1 appears in invariant
    |
    place p1 coefficient in the invariant

    p1     = 0 => b_p1   = 0
    |           ------------
    |               |
    |            place p1 does not appear in invariant
    |
    place p1 coefficient in the invariant

    p2    > 0 => b_p2    = 1
    p2    = 0 => b_p2    = 0
    p3    > 0 => b_p3    = 1
    p3    = 0 => b_p3    = 0
    bit1  > 0 => b_bit1  = 1
    bit1  = 0 => b_bit1  = 0
    nbit1 > 0 => b_nbit1 = 1
    nbit1 = 0 => b_nbit1 = 0

    q1    > 0 => b_q1    = 1
    q1    = 0 => b_q1    = 0
    q2    > 0 => b_q2    = 1
    q2    = 0 => b_q2    = 0
    q3    > 0 => b_q3    = 1
    q3    = 0 => b_q3    = 0
    nbit2 > 0 => b_nbit2 = 1
    nbit2 = 0 => b_nbit2 = 0

    b_p1 + b_p2 + b_p3 + b_bit1 + b_nbit1 + b_q1 + b_q2 + b_q3 + b_q4 + b_q5
         + b_nbit2 < 4
    --------------   |
                |    |
                |    number of places appearing in current invariant for A'
                |    = #{s | A'(s) > 0} = #{p1, p2, p3, bit1}
                |
  number of places appearing in new invariant
  
  - Model A' for C' \cup C_M:

    p1       = 1
    p2       = 1
    p3       = 1
    bit1     = 0
    nbit1    = 0
    q1       = 0
    q2       = 0
    q3       = 0
    q4       = 0
    q5       = 0
    nbit2    = 0
    target_1 = 1
    
    
  - Minimized Invariant:

    p1 + p2 + p3 <= 1
\end{verbatim}
    
\newpage

\section{Method Invariant by Refinement}

\begin{verbatim}
* Code, property, and Petri net: same as in section Method Safety by Refinement.

* Method Invariant by Refinement
\end{verbatim}

\input{fig_dia_method_invariant_by_refinement}

\input{fig_method_invariant_by_refinement}

\begin{verbatim}
* Subprocedures TrapConditions and \Delta are the same as
  in Method Safety by Refinement

* Subprocedures \mathcal{C'} and Inv are the same as
  in Method Invariant
\end{verbatim}

\newpage

\begin{verbatim}
* Example:

  - Using property 1

  - Trap constraints as in example from section Method Safety by Refinement.
  
  - Dual state constraints C':

    0        >=    a  - b
    0        >= (- a) + b

    a        <  target_1 + trap_1

    a        >= trap_1
    b        >= target_1
    nbit2    >= trap_1
    target_1 >= 0
    trap_1   >= 0

  - Model A':

    a        = 1
    b        = 1
    nbit2    = 1
    target_1 = 1
    trap_1   = 1
    
  - Invariant:

    a     + nbit2 >= 1
    a + b + nbit2 <= 1
\end{verbatim}

\input{sec_experiments}
\bibliographystyle{abbrv}
\bibliography{references}

\end{document}

