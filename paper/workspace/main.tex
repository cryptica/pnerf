\documentclass{article}

\usepackage{amsmath}
\usepackage[usenames,dvipsnames]{color}
\usepackage{multirow}
\usepackage{listings}
\usepackage[a4paper, top=2cm, bottom=3cm, left=2cm, right=2cm]{geometry}

\usepackage{tikz}
\usetikzlibrary{arrows,shapes,shapes.multipart,shapes.geometric,
	snakes,automata,backgrounds,petri,calc}
\usetikzlibrary{positioning}

\newcommand{\bfc}{{\sc Bfc}}
\newcommand{\mist}{{\sc Mist}}
\newcommand{\pnerf}{{\sc Pnerf}}
\newcommand{\zthree}{{\sc Z3}}
\newcommand{\ttt}[1]{\texttt{#1}}
 
\tikzstyle{place}=[circle,thick,draw=black!75,fill=white!20,
  	minimum size=6mm]
\tikzstyle{red place}=[place,draw=red!75,fill=red!20]
\tikzstyle{blue place}=[place,draw=blue!75,fill=blue!20]
\tikzstyle{transition}=[rectangle,thick,draw=black!75,
  	fill=black!20,minimum size=4mm]

\tikzstyle{state}=[draw, ellipse, aspect=2]
\tikzstyle{action}=[draw, rectangle, align=center]
\tikzstyle{decision}=[draw, diamond, aspect=2, align=center]
\tikzstyle{print}=[draw, trapezium, trapezium left angle=70, trapezium right angle=-70]
\tikzstyle{every edge}=[draw, ->, >=stealth, shorten >=2pt, shorten <=2pt]

\begin{document}

\title{Report on a Safety Checker for Petri nets}
\author{Philipp Meyer \and Rusl\'{a}n Ledesma-Garza}
% \institute{Technische Universit\"at M\"unchen}
\date{Wed Nov 13 09:11:15 CEST 2013}



\section{Preliminaries}


\begin{verbatim}
* Petri net:
 N = (S, T, E, M0), where
 S : places
 T : transitions
 E : edges
 M0: initial marking

* Property:
 P, linear arithmetic formula
\end{verbatim}
\iffalse
\begin{verbatim}
 Examples:
  x + y < 0
  x + y < 0 \\and x + z > 0
  x + y < 0 \\or  x + z > 0

 ~P = (x + y <  0 \\and x + z >  0) \\or  x + z >  0
  P = (x + y >= 0 \\or  x + z <= 0) \\and x + z <= 0
\end{verbatim}
\fi

\newpage
\section{Method Safety}

The method Safety checks that a given Petri net \verb=N= never violates a property \verb=P=.
We present the method Safety by example on a simplified mutual exclusion algorithm by Delzanno2001.

\begin{verbatim}
* Code

bool m = false;

// Thread 1:
while (true) {
  if (! test_and_set(m)) {
    // critical section 1
    m = false
  }
  if (! test_and_set(m)) {
    // critical section 2
    m = false
  }
}

// Thread 2:
while (true) {
  if (! test_and_set(m)) {
    // critical section 1
    m = false
  }
  if (! test_and_set(m)) {
    // critical section 2
    m = false
  }
}

* Property: Thread 1 and Thread 2 are never in any critical section at the same time.

* Petri net:

\end{verbatim}

\begin{center}
  \begin{tikzpicture}[node distance=2cm]
    \node[blue place, tokens=2, label=above:nc] (nc) {};
    \node[place, tokens=1, label=above:m, below of=nc] (s) {};
    \node[red place, label=above:cs1, left of=s] (cs1) {};
    \node[red place, label=above:cs2, right of=s] (cs2) {};
    \node[transition, label=above:t1] (t1) at ($(s)!0.5!(cs1) + (0,1cm)$) {}
    edge [pre] (nc)
    edge [pre] (s)
    edge [post] (cs1);
    \node[transition, label=above:t2] (t2) at ($(s)!0.5!(cs2) + (0,1cm)$) {}
    edge [pre] (nc)
    edge [pre] (s)
    edge [post] (cs2);
    \node[transition, label=below:t3] (t3) at ($(s)!0.5!(cs1) - (0,1cm)$) {}
    edge [pre] (cs1)
    edge [post] (s)
    edge [post,bend left,min distance=3cm, out=105, in=105] (nc);
    \node[transition, label=below:t4] (t4) at ($(s)!0.5!(cs2) - (0,1cm)$) {}
    edge [pre] (cs2)
    edge [post] (s)
    edge [post,bend right,min distance=3cm, out=-105, in=-105] (nc);
  \end{tikzpicture}
\end{center}

\begin{verbatim}
* Property: P = ( cs1 + cs2 <= 1 )
\end{verbatim}

\newpage
\begin{verbatim}
* Method Safety:

  Subprocedure \mathcal{C} constructs state constraints C corresponding to N.
\end{verbatim}

\begin{center}
  \begin{tikzpicture}
    \node[state] (begin) {BEGIN};
    \node[action, below=of begin] (c) {$C:=\mathcal C(N)$};
    \node[decision, below=of c] (satc) {$\text{SAT}(C \cup \{\neg P\})$};
    \node[print, right=of satc] (yes) {YES};
    \node[print, below=of satc] (dontknow) {Don't know};
    \node[state, right=of yes] (end1) {END};
    \node[state, below=of dontknow] (end2) {END};
    
    \draw (begin) edge (c);
    \draw (c) edge (satc);
    \draw (satc) edge node[above]{NO} (yes);
    \draw (yes) edge (end1);
    \draw (satc) edge node[right]{YES} (dontknow);
    \draw (dontknow) edge (end2);
  \end{tikzpicture}
\end{center}

\begin{verbatim}
* Property of state constraints C: If C U {\neg P} is unsat then N |= P.

* Example:
  - State constraints C:

    Place equations:
  
    nc      = 2 - t1 - t2 + t3 + t4
    ^         ^   ^    ^    ^    ^
    |         |   |    |    |    |
    |         |   ------    ------
    |         |      |         |
    |         |      |       # of tokens given to nc
    |         |      |    
    |         |    # of tokens taken from nc
    |         |
    |      initial number of tokens in nc
    |
    number of tokens in nc
  
    m     = 1 - t1 - t2 + t3 + t4
    cs1   = 0 + t1 - t3
    cs2   = 0 + t2 - t4
  
    Non-negativity conditions:
  
    nc  >= 0
    m   >= 0
    cs1 >= 0
    cs2 >= 0
    t1  >= 0
    t2  >= 0
    t3  >= 0
    t4  >= 0
\end{verbatim}

\newpage
\begin{verbatim}
* Place equation:
  
  For a given place s the place equation is

  # of tokens in s = initial number of tokens of place s - # times each output transition of s fires + # times each input transition of s fires

* Non-negativity conditions:

  # of tokens in place s           >= 0
  # of times transition t is fired >= 0

* Subprocedure \mathcal{C}:

  Input:
    (S, T, E, M0) : Petri net
  Output:
    C : State constraints

  TODO: Unroll pseudocode?
\end{verbatim}

\newpage
\section{Method Invariant}

The method Invariant constructs an invariant \verb=I= for given Petri net \verb=N= and \verb=P= when \verb=N= never violates \verb=P=.
We present the method Invariant by example on a simplified mutual exclusion algorithm by Delzanno2001.

\begin{verbatim}
* Code, property, and Petri net: same as in section Method Safety.
\end{verbatim}

\begin{verbatim}
* Method Invariant

  Subprocedure \mathcal{C'} constructs dual state constraints C' corresponding to N and P.
  Subprocedure Model returns assignment A such that A satisfies C'.
  Subprocedure Inv constructs invariant I corresponding to N, P, and A.
\end{verbatim}

\begin{center}
  \begin{tikzpicture}
    \node[state] (begin) {BEGIN};
    \node[action, below=of begin] (c) {$C':=\mathcal C'(N, P)$};
    \node[decision, below=of c] (satc) {$\text{SAT}(C')$};
    \node[print, right=of satc] (noinv) {No Invariant};
    \node[action, below=of satc] (inv) {$A:=\text{Model}(C')$\\
      $I := \text{Inv}(N, P, A)$};
    \node[print, below=of inv] (printinv) {Invariant: $I$};
    \node[state, right=of noinv] (end1) {END};
    \node[state, below=of printinv] (end2) {END};
    
    \draw (begin) edge (c);
    \draw (c) edge (satc);
    \draw (satc) edge node[above]{NO} (noinv);
    \draw (satc) edge node[right]{YES} (inv);
    \draw (noinv) edge (end1);
    \draw (inv) edge (printinv);
    \draw (printinv) edge (end2);
  \end{tikzpicture}
\end{center}

\begin{verbatim}
* Property of dual state constraints C':  If C' is sat then N |= P.

* Property of invariant I:
  - I is reachable: For each reachable marking M, I(M) is valid
  - I is safe:      For markings that violate the property, I(M) is unsat
  - I is inductive: For each marking M, if I(M) is valid and M -> M1 then I(M1) is valid
\end{verbatim}

\newpage
\begin{verbatim}
* Example:
  - Dual state constraints C':

    - nc - m + cs1 <= 0
    - nc - m + cs2 <= 0
      nc + m - cs1 <= 0
      nc + m - cs2 <= 0

    2 \cdot nc + m < 2 \cdot target1

    Non-negativity conditions:

    target1 >= 0
    nc      >= 0
    m       >= 0
    cs1     >= target1
    cs2     >= target1
  
  - Model A:

    target1 = 1
    nc      = 0
    m       = 1
    cs1     = 1
    cs2     = 1
    
  - Invariant:

    cs1 + cs2 + m <= 1

\end{verbatim}

\newpage
\begin{verbatim}
* Derivation of invariant I for Petri net N that satisfies property P:

  M                                    : marking          ~ places
  C                                    : incidence matrix ~ rows correspond to places, columns correspond to transitions, relates places to transitions
  X                                    : firing vector    ~ transitions

  The following constraints C1 are unsat.
  M = M0 + C*X                         : place equations
  M >= 0                               : non-negativity conditions for places
  X >= 0                               : non-negativity conditions for transitions
  AM >= b                              : property P negated

  Substitute M to obtain constraints C2.
  A(M0 + CX) >= b                      : property P negated
  M0 + CX >= 0                         : non-negativity conditions for places
  X >= 0                               : non-negativity conditions for transitions

  Rewrite each system to obtain constraints C3.
  (-A*C)      (A*M0-b)                 : property P negated
  (  -C)*X <= (  M0  )                 : non-negativity conditions for places
  (  -I)      (   0  )                 : non-negativity conditions for transitions

  Apply Farkas' Lemma to obtain constraints C4.
  yT*(-A*C)                            : 
     (  -C) = 0                        : 
     (  -I)                            : 

  yT*(A*M0-b)                          : 
     (  M0  ) < 0                      : 
     (   0  )                          : 

  y >= 0                               : 

  The constraints C4 are sat iff the following constraints C5 are sat.
  y1 * A * C + y2 * C + y3 = 0         : 
  y1 * (A*M - b) + y2 * M0 < 0         : 
  y1 >= 0                              : 
  y2 >= 0                              : 
  y3 >= 0                              : 

  The constraints C5 are sat iff the following constraints C6 are sat.
  (y1 * A + y2) * C  <= 0              : 
  (y1 * A + y2) * M0 < y1 * b          : 
  y1 >= 0                              : 
  y2 >= 0                              : 

  The constraints C6 are sat iff the following constraints C' are sat.
  \lambda * C  <= 0                    : inductivity constraint
  \lambda * M0 < y1 * b                : safety constraint
  \lambda >= y1 * A                    : property constraint
  y1 >= 0                              : non-negativity constraint

  For \lambda satisfying C' the invariant is the following.
  I(M) = (\lambda * M <= \lambda * M0) : invariant
\end{verbatim}

\newpage
\begin{verbatim}
* Subprocedure \mathcal{C'}:

  Input:
    (S, T, E, I) : Petri net
    P            : Property
  Output:
    C'           : Dual state constraints

Input:
 N = (S, T, E, I)
   = ( (nc m cs1 cs2) (t1 t2 t3 t4) (e1 ... en) (2 1 0 0) )
 P = ( cs1 + cs2 <= 1 )

TODO: Unroll pseudocode?


* Subprocedure Inv:

  Input:
    (S, T, E, I) : Petri net
    A            : Satisfying assignment for C'

  Output:
    I            : Invariant

TODO: Unroll pseudocode?
\end{verbatim}

\newpage
\section{Method Safety by Refinement}

The method Safety by Refinement applies trap conditions to check that a given Petri net \verb=N= never violates a property \verb=P=.
We present the method Invariant by example on a mutual exclusion algorithm by Delzanno2001.

\begin{verbatim}

* Code

bool m1 = false;
bool m2 = false;

// Thread 1:
while (true) {
  if (! m2 && ! test_and_set(m1)) {
    // critical section 1
    m1 = false
  }
  if (! m1 && ! test_and_set(m2)) {
    // critical section 2
    m2 = false
  }
}

// Thread 2:
while (true) {
  if (! m2 && ! test_and_set(m1)) {
    // critical section 1
    m1 = false
  }
  if (! m1 && ! test_and_set(m2)) {
    // critical section 2
    m2 = false
  }
}

Property: Thread 1 and Thread 2 are never in any critical section at the same time.

* Petri net:
\end{verbatim}
\begin{center}
\begin{tikzpicture}[node distance=2cm]
  \node[blue place, tokens=2, label=above:nc] (nc) {};
  \node[place, tokens=1, label=right:m2, below of=nc, xshift=+0.75cm] (s2) {};
  \node[place, tokens=1, label=left:m1, below of=nc, xshift=-0.75cm] (s1) {};
  \node[red place, label=above:cs1, left of=s1] (cs1) {};
  \node[red place, label=above:cs2, right of=s2] (cs2) {};
  \node[transition, label=above:t1] (t1) at ($(s1)!0.5!(cs1) + (0,1cm)$) {}
	edge [pre] (nc)
	edge [pre] (s1)
	edge [pre] (s2)
	edge [post] (cs1)
	edge [post] (s2);
  \node[transition, label=above:t2] (t2) at ($(s2)!0.5!(cs2) + (0,1cm)$) {}
	edge [pre] (nc)
	edge [pre] (s2)
	edge [pre] (s1)
	edge [post] (cs2)
	edge [post] (s1);
  \node[transition, label=below:t3] (t3) at ($(s1)!0.5!(cs1) - (0,1cm)$) {}
	edge [pre] (cs1)
	edge [post] (s1)
	edge [post,bend left,min distance=3cm, out=115, in=115] (nc);
  \node[transition, label=below:t4] (t4) at ($(s2)!0.5!(cs2) - (0,1cm)$) {}
	edge [pre] (cs2)
	edge [post] (s2)
	edge [post,bend right,min distance=3cm, out=-115, in=-115] (nc);
\end{tikzpicture}
\end{center}

\newpage
\begin{verbatim}
* Method Safety:

  Subprocedure TrapConditions constructs trap conditions C_\theta corresponding to N and A.
  Subprocedure \Delta constructs refinement constraint \delta corresponding to A_\theta.
\end{verbatim}
\begin{center}
\begin{tikzpicture}
  \node[state] (begin) {BEGIN};
  \node[action, below=of begin] (c) {$C:=\mathcal C(N)$};
  \node[decision, below=of c] (satc) {$\text{SAT}(C \cup \{\neg P\})$};
  \node[action, below=of satc] (modelc) {$A:=\text{Model}(C \cup \{\neg P\})$\\
                               	$C_{\theta}:=\text{TrapConditions}(N, A)$};
  \node[decision, below=of modelc] (satctheta) {$\text{SAT}(C_\theta)$};
  \node[action, below=of satctheta] (modelctheta) {$A_\theta:=\text{Model}(C_\theta)$\\
                                    	$\delta:=\Delta(A_\theta)$\\
                                    	$C:=C \cup \{\delta\}$};
  \node[print, right=of satc] (yes) {YES};
  \node[print, right=of satctheta] (dontknow) {Don't know};
  \node[state, right=of yes] (end1) {END};
  \node[state, right=of dontknow] (end2) {END};

  \draw (begin) edge (c);
  \draw (c) edge coordinate[pos=.5] (edgein) (satc);
  \draw (satc) edge node[above]{NO} (yes);
  \draw (yes) edge (end1);
  \draw (satc) edge node[right]{YES} (modelc);
  \draw (modelc) edge (satctheta);
  \draw (satctheta) edge node[above]{NO} (dontknow);
  \draw (dontknow) edge (end2);
  \draw (satctheta) edge node[right]{YES} (modelctheta);
  \draw (modelctheta.south) -- ([yshift=-0.5cm] modelctheta.south)
  -| ([xshift=-2cm] modelctheta.west) |- (edgein);
\end{tikzpicture}
\end{center}

\begin{verbatim}
* Property of trap conditions C_\theta: If C_\theta is sat then there is a set S such that
  1. S is a trap in the net N
  2. S is marked in the initial marking M0
  3. S is unmarked in the assignment A

* Property of A_\theta: for each place s, A_\theta(s) iff s \in S

* Property of refinement constraint \delta: Constraint \delta refines the abstraction, i.e.
  1. A ^ \delta is unsat (\delta excludes A)
  2. N |= \delta is sat  (\delta is a property of N)
\end{verbatim}

\newpage
\begin{verbatim}
* Example
  - State constraints C:
    nc  =  2 - t1 - t2 + t3 + t4
    m1  =  1 - t1 + t3
    m2  =  1 - t2 + t4
    cs1 =  0 + t1 - t3
    cs2 =  0 + t2 - t4
    nc  >= 0
    m1  >= 0
    m2  >= 0
    cs1 >= 0
    cs2 >= 0
    t1  >= 0
    t2  >= 0
    t3  >= 0
    t4  >= 0

  - Assignment A:
    nc  = 0
    m1  = 0
    m2  = 0
    cs1 = 1
    cs2 = 1
    t1  = 1
    t2  = 1
    t3  = 0
    t4  = 0

  - Trap conditions C_\theta:

    - Trap implications:

    cs1 => m1 \/ nc
    ^      ^     ^
    |      |     |
    |      |     nc \in S
    |      |
    |      m1 \in S
    |
    cs1 \in S
    
    cs2 => m2 \/ nc
    nc  => (m2 \/ cs1) /\ (m1 \/ cs2)
    m1  => (m2 \/ cs1) /\ (m1 \/ cs2)
    m2  => (m2 \/ cs1) /\ (m1 \/ cs2)

    - At least one of the intially marked places belongs to S:
    nc \/ m1 \/ m2

    - None of the marked places in A belongs to S:
    ~cs1 /\ ~cs2

  - Assignment A_\theta:
    nc  = false
    m1  = true
    m2  = true
    cs1 = false
    cs2 = false
\end{verbatim}

\newpage
\begin{verbatim}
  - Refinement constraint \delta:
    m1 + m2 >= 1
    ^    ^
    |    |
    ------
      |
      S = {m1, m2}, therefore \delta excludes assignment A in the next iteration

* Trap implication:

  place s \in S =>    /\       \    /
                     /  \       \  /     place p \in S
                    /    \       \/
                   t \in s*   p \in t*   


  "if s is in trap S then for each output transition t at least one successor p is in trap S"


* Refinement constraint \delta:

  \Sigma s >= 1  
  A(s)

  "At least one place in S is always marked"


* Subprocedure TrapConditions:

  Input:
    (S, T, E, M0) : Petri net
    A             : Satisfying assignment for C \cup { ~P }
  Output:
    C_\theta      : Trap conditions

  TODO: Unroll pseudocode?

* Subprocedure \Delta:

  Input:
    A_\theta      : Satisfying assignment for C_\theta
  Output:
    \delta        : Refinement constraint \delta

  TODO: Unroll pseudocode?
\end{verbatim}

\newpage
\section{Benchmarks of \bfc}

We experimented on the benchmarks \ttt{cprover-PN} and
\ttt{cprover\_software\_analysis}
available at
\ttt{http://www.mpi-sws.org/\~{}jkloos/iic-experiments/cprover.zip}.
The set of benchmarks consists 77 benchmarks, 26 positive and 51 negative.
We applied 8 tool configurations to the set of benchmarks.
Table~\ref{bfc-experiments} shows the corresponding experimental results.

\begin{table}[h]
\begin{center}
  \begin{tabular}{ | r | p{7cm} | r | r | r | r | } %
    \hline
    \multicolumn{2}{|l|}{Configuration} & pos & neg & don't know & TO \\
    \hline
    C1 & State constraint over real numbers & 23 &  0 & 54 &  0 \\
    C2 & State constraint over integers        & 23 &  0 & 54 &  0 \\
    \hline
    C3 & C2 + TrapConditions                   & 23 &  0 & 54 &  0 \\
    C4 & C3 + SubnetTrapConditions         & 23 &  0 & 50 &  4 \\
    C5 & C4 + EmptyTrapConditions          & 23 &  0 & 46 &  8 \\
    \hline
    C6 & C1 + state space exploration \& TO 1\,min & 26 & 34 & 0 & 17 \\
    C7 & C1 + state space exploration \& TO 10\,min & 26 & 39 & 0 & 12 \\
    C8 & C1 + state space exploration \& TO 8\,h   & 26 & 45 & 0 &  6 \\
    \hline
    C10 & Method Invariant                  & 23 &  0 & 54 &  0 \\
    \hline
  \end{tabular}
\end{center}
\caption{Experimental results for the benchmarks of \bfc}
\label{bfc-experiments}
\end{table}

Observations:
\begin{itemize}
\item State constraints over integers or reals correctly determine that the 23 benchmarks in Appendix~\ref{bfc-experiments-c1} are positive.
\item Composing state space constraints with concrete state space
  exploration gives the following 3 additional positives.
\begin{verbatim}
cprover-PN/lamport
cprover-PN/newdekker
cprover-PN/peterson
\end{verbatim}
\end{itemize}


\newpage
\section{Benchmarks of \mist}

We experimented on the benchmarks available at \\
\ttt{https://github.com/pierreganty/mist/tree/master/examples/boundedPN}
and \\
\ttt{https://github.com/pierreganty/mist/tree/master/examples/PN}.
The set of benchmarks consists 27 benchmarks, 23 positive and 4 negative.
We applied 6 tool configurations to the set of benchmarks.
Table~\ref{mist-experiments} shows the corresponding experimental results.

\begin{table}[h]
\begin{center}
  \begin{tabular}{ | r | p{6cm} | r | r | r | r | }
    \hline
    \multicolumn{2}{|l|}{Configuration} & pos & neg & don't know & TO \\
    \hline
    C1 & State constraint with real numbers & 14 &  0 & 13 &  0 \\
    C2 & State constraint with integers     & 14 &  0 & 13 &  0 \\
    \hline
    C3 & C2 + TrapConditions               & 20 &  0 &  7 &  0 \\
    C4 & C3 + SubnetTrapConditions         & 21 &  0 &  6 &  0 \\
    C5 & C4 + EmptyTrapConditions          & 21 &  0 &  6 &  0 \\
    \hline
    C9 & C4 + state space exploration \& TO 4\,h & 21 &  2 & 0 &  4 \\
    \hline
    C10 & Method Invariant                  & 14 &  0 & 13 &  0 \\
    \hline
  \end{tabular}
\end{center}
\caption{Experimental results for the benchmarks of \mist}
\label{mist-experiments}
\end{table}

Observations:
\begin{itemize}
\item State constraints over integers or reals correctly determine that the 14 benchmarks in Appendix~\ref{mist-experiments-c1} are positive.
\item Composing state constraints with TrapConditions gives the following 6 additional positives.
\begin{verbatim}
PN/pingpong
PN/basicME
PN/multiME
boundedPN/lamport
boundedPN/newdekker
boundedPN/peterson
\end{verbatim}
\item Composing state constraints with TrapConditions and SubnetTrapConditions gives the additional positive \ttt{PN/manufacturing}.
  \item The remaining positive benchmarks are the following.
\begin{verbatim}
PN/extendedread-write
PN/extendedread-write-smallconsts
\end{verbatim}
\end{itemize}




































\iffalse

\paragraph{Intermediate results}
Constraints $\mathcal C'(N, P)$ with
$Y_1 = \begin{pmatrix}target1 \end{pmatrix}$,
$Y_2 =\begin{pmatrix}nc & m & cs1 & cs2\end{pmatrix}$,
$A =\begin{pmatrix}0 & 0 & 1 & 1 \end{pmatrix}$ and
$b =\begin{pmatrix}2 \end{pmatrix}$:

\begin{align*}
  target1 - nc - m + cs1 \le& 0 \\ 
  target1 - nc - m + cs2 \le& 0 \\ 
  - target1 + nc + m - cs1 \le& 0 \\ 
  - target1 + nc + m - cs2 \le& 0 \\ 
2 \cdot nc + m <& 2 \cdot target1 \\
  target1 \ge& 0 \\
  nc \ge& 0 \\
  m \ge& 0 \\
  cs1 \ge& 0 \\
  cs2 \ge& 0
\end{align*}

Satisfying assignment is $Y_1 = \begin{pmatrix} 1 \end{pmatrix}$ and
$Y_2 = \begin{pmatrix}0 & 1 & 0 & 0 \end{pmatrix}$

Invariant $\text{Inv}(N, P, A) = (cs1 + cs2 + m \le 1)$

\paragraph{Technique}
\begin{align*}
  \mathcal C'(N, P) =& ( ( ( Y_1 \cdot A + Y_2) \cdot C \le 0) \land \\
& ((Y_1 \cdot A + Y_2) \cdot M_0 < Y_1 \cdot b) \land \\
& (Y_1 \ge 0) \land (Y_2 \ge 0)) \\
  \text{Inv}(N, P, A) =& ( ( Y_1 \cdot A + Y_2) \cdot M \le ( Y_1 \cdot A + Y_2) \cdot M_0)
\end{align*}
where $M_0$ is the initial marking, $C$ is the incidence matrix of the net and
$A\cdot M \ge b$ is equivalent to $\neg P$.

\paragraph{Method Invariant}
\mbox{ } \\
\begin{tikzpicture}
  \node[state] (begin) {BEGIN};
  \node[action, below=of begin] (c) {$C':=\mathcal C'(N, P)$};
  \node[decision, below=of c] (satc) {$\text{SAT}(C')$};
  \node[print, right=of satc] (noinv) {No Invariant};
  \node[action, below=of satc] (inv) {$A_\theta:=\text{Model}(C')$\\
                                  	$I := \text{Inv}(N, P, A)$};
  \node[print, below=of inv] (printinv) {Invariant: $I$};
  \node[state, right=of noinv] (end1) {END};
  \node[state, below=of printinv] (end2) {END};
 
  \draw (begin) edge (c);
  \draw (c) edge (satc);
  \draw (satc) edge node[above]{NO} (noinv);
  \draw (satc) edge node[right]{YES} (inv);
  \draw (noinv) edge (end1);
  \draw (inv) edge (printinv);
  \draw (printinv) edge (end2);
\end{tikzpicture}

\section{Method Safety by Refinement}

\paragraph{Example: Mutual exclusion algorithm in Delzanno2001}

\begin{verbatim}
* Code

bool m1 = false;
bool m2 = false;

// Thread 1:
while (true) {
  if (! m2 && ! test_and_set(m1)) {
    // critical section 1
    m1 = false
  }
  if (! m1 && ! test_and_set(m2)) {
    // critical section 2
    m2 = false
  }
}

// Thread 2:
while (true) {
  if (! m2 && ! test_and_set(m1)) {
    // critical section 1
    m1 = false
  }
  if (! m1 && ! test_and_set(m2)) {
    // critical section 2
    m2 = false
  }
}

Property: The number of threads in critical sections should be at most 1

* Petri net

Place m1 is marked in the net exactly if m1 is false in the algorithm.
Place m2 is marked in the net exactly if m2 is false in the algorithm.

\end{verbatim}

\paragraph{Example: Petri net for mutual exclusion algorithm in Delzanno2001}
\mbox{ } \\
\begin{tikzpicture}[node distance=2cm]
  \node[blue place, tokens=2, label=above:nc] (nc) {};
  \node[place, tokens=1, label=right:m2, below of=nc, xshift=+0.75cm] (s2) {};
  \node[place, tokens=1, label=left:m1, below of=nc, xshift=-0.75cm] (s1) {};
  \node[red place, label=above:cs1, left of=s1] (cs1) {};
  \node[red place, label=above:cs2, right of=s2] (cs2) {};
  \node[transition, label=above:t1] (t1) at ($(s1)!0.5!(cs1) + (0,1cm)$) {}
	edge [pre] (nc)
	edge [pre] (s1)
	edge [pre] (s2)
	edge [post] (cs1)
	edge [post] (s2);
  \node[transition, label=above:t2] (t2) at ($(s2)!0.5!(cs2) + (0,1cm)$) {}
	edge [pre] (nc)
	edge [pre] (s2)
	edge [pre] (s1)
	edge [post] (cs2)
	edge [post] (s1);
  \node[transition, label=below:t3] (t3) at ($(s1)!0.5!(cs1) - (0,1cm)$) {}
	edge [pre] (cs1)
	edge [post] (s1)
	edge [post,bend left,min distance=3cm, out=115, in=115] (nc);
  \node[transition, label=below:t4] (t4) at ($(s2)!0.5!(cs2) - (0,1cm)$) {}
	edge [pre] (cs2)
	edge [post] (s2)
	edge [post,bend right,min distance=3cm, out=-115, in=-115] (nc);
\end{tikzpicture}
\begin{align*}
  P &= ( cs1 + cs2 \le 1 ) \\
  \neg P &= ( cs1 + cs2 \ge 2 )
\end{align*}

\paragraph{Intermediate results}
Constraints $\mathcal C(N)$ with
$M =\begin{pmatrix}nc & m1 & m2 & cs1 & cs2 \end{pmatrix}^T$,
$M_0 =\begin{pmatrix}2 & 1 & 1 & 0 & 0 \end{pmatrix}^T$,
$X =\begin{pmatrix}t1 & t2 & t3 & t4 \end{pmatrix}^T$ and
$C =\begin{pmatrix}
  -1 & -1 & 1 & 1 \\
  -1 &  0 & 1 & 0 \\
   0 & -1 & 0 & 1 \\
  1 & 0 & -1 & 0 \\
  0 & 1 & 0 & -1
\end{pmatrix}$:
\begin{align*}
  nc   =& 2 - t1 - t2 + t3 + t4 \\
  m1  =& 1 - t1 + t3 \\
  m2  =& 1 - t2 + t4 \\
  cs1 =& 0 + t1 - t3 \\
  cs2 =& 0 + t2 - t4 \\
  nc \ge& 0 \\
  m1 \ge& 0 \\
  m2 \ge& 0 \\
  cs1 \ge& 0 \\
  cs2 \ge& 0
\end{align*}

Satisfying assignment is
$M =\begin{pmatrix}0 & 0 & 0 & 1 & 1 \end{pmatrix}^T$ and
$X =\begin{pmatrix}1 & 1 & 0 & 0 \end{pmatrix}^T$.

A set satisfying the trap conditions is $S = \{m1, m2\}$.

The trap constraint is $\delta = (m1 + m2 \ge 1)$.

With the additional constraint, the set of constraints is unsatisfiable.

\paragraph{Technique trap conditions} For a petri net $N$ and an assignment $A$,
find a set $S$ that satisfies
\begin{enumerate}
  \item $S$ is a trap in the net $N$.
  \item $S$ is marked in the initial marking $M_0$.
  \item $S$ is unmarked in the assignment $A$.
\end{enumerate}
For such a set $S$, generate a constraint
$\delta = \left( \sum_{s \in S} s \ge 1 \right)$, ensuring the
trap is marked in any assignment.

\paragraph{Method Safety by Refinement}
\mbox{ } \\
\begin{tikzpicture}
  \node[state] (begin) {BEGIN};
  \node[action, below=of begin] (c) {$C:=\mathcal C(N)$};
  \node[decision, below=of c] (satc) {$\text{SAT}(C \cup \{\neg P\})$};
  \node[action, below=of satc] (modelc) {$A:=\text{Model}(C \cup \{\neg P\})$\\
                               	$C_{\theta}:=\text{TrapConditions}(N, A)$};
  \node[decision, below=of modelc] (satctheta) {$\text{SAT}(C_\theta)$};
  \node[action, below=of satctheta] (modelctheta) {$A_\theta:=\text{Model}(C_\theta)$\\
                                    	$\delta:=\Delta(A_\theta)$\\
                                    	$C:=C \cup \{\delta\}$};
  \node[print, right=of satc] (yes) {YES};
  \node[print, right=of satctheta] (dontknow) {Don't know};
  \node[state, right=of yes] (end1) {END};
  \node[state, right=of dontknow] (end2) {END};

  \draw (begin) edge (c);
  \draw (c) edge coordinate[pos=.5] (edgein) (satc);
  \draw (satc) edge node[above]{NO} (yes);
  \draw (yes) edge (end1);
  \draw (satc) edge node[right]{YES} (modelc);
  \draw (modelc) edge (satctheta);
  \draw (satctheta) edge node[above]{NO} (dontknow);
  \draw (dontknow) edge (end2);
  \draw (satctheta) edge node[right]{YES} (modelctheta);
  \draw (modelctheta.south) -- ([yshift=-0.5cm] modelctheta.south)
  -| ([xshift=-2cm] modelctheta.west) |- (edgein);
\end{tikzpicture}

\section{Method Invariant by Refinement}

\paragraph{Example}
See example for method Safety by Refinement.

\paragraph{Intermediate results}
Constraints $\mathcal C'(N)$ with
$Y_1 = \begin{pmatrix}target1 \end{pmatrix}$,
$Y_2 = \begin{pmatrix}trap2 \end{pmatrix}$,
$Y_3 =\begin{pmatrix}nc & m & cs1 & cs2\end{pmatrix}$,
the trap from the trap refinement as
$D =\begin{pmatrix}0 & 1 & 1 & 0 & 0 \end{pmatrix}$,
$A =\begin{pmatrix}0 & 0 & 0 & 1 & 1 \end{pmatrix}$ and
$b =\begin{pmatrix}1 \end{pmatrix}$:

\begin{align*}
  target1 - trap1 - nc - m1 + cs1 \le& 0 \\ 
  target1 - trap1 - nc - m2 + cs2 \le& 0 \\ 
  - target1 + trap1 + nc + m1 - cs1 \le& 0 \\ 
  - target1 + trap1 + nc + m2 - cs2 \le& 0 \\ 
2 \cdot trap1 + 2 \cdot nc + m1 + m2 <& 2 \cdot target1 + trap1 \\
  target1 \ge& 0 \\
  trap1 \ge& 0 \\
  nc \ge& 0 \\
  m1 \ge& 0 \\
  m2 \ge& 0 \\
  cs1 \ge& 0 \\
  cs2 \ge& 0
\end{align*}

Satisfying assignment is
$Y_1 = \begin{pmatrix} 1 \end{pmatrix}$,
$Y_2 = \begin{pmatrix} 1 \end{pmatrix}$ and
$Y_3 = \begin{pmatrix}0 & 0 & 0 & 0 & 0 \end{pmatrix}$.

Invariant $\text{Inv}(N, D, P, A) =
((cs1 + cs2 + m1 + m2 \le 2) \land (m1 + m2 \ge 1))$.

\paragraph{Technique}
\begin{align*}
  \mathcal C'(N, D, P) =& ( ( ( Y_1 \cdot A + Y_2 \cdot D + Y_3) \cdot C \le 0) \land \\
& ((Y_1 \cdot A + Y_2 \cdot D + Y_3) \cdot M_0 < Y_1 \cdot b + Y_2 \cdot \mathbf{1}) \land \\
& (Y_1 \ge 0) \land (Y_2 \ge 0) \land (Y_3 \ge 0)) \\
  \text{Inv}(N, D, P, A) =& ( ( Y_1 \cdot A + Y_2 \cdot D + Y_3) \cdot M \le ( Y_1 \cdot A + Y_2 \cdot D + Y_3) \cdot M_0) \land ( D \cdot M \ge \mathbf{1} )
\end{align*}
where $M_0$ is the initial marking, $C$ is the incidence matrix of the net, $A\cdot M \ge b$ is equivalent to $\neg P$ and $D \cdot M \ge \mathbf{1}$ is equivalent to the trap constraints.

\paragraph{Method Invariant by Refinement}
\mbox{ } \\
\begin{tikzpicture}
  \node[state] (begin) {BEGIN};
  \node[action, below=of begin] (c) {$C:=\mathcal C(N)$\\
                                 	$D:=\{\}$};
  \node[decision, below=of c] (satc) {$\text{SAT}(C \cup \{\neg P\})$};
  \node[action, below=of satc] (modelc) {$A:=\text{Model}(C \cup \{\neg P\})$\\
                                   	$C_{\theta}:=\text{TrapConditions}(N, A)$};
  \node[decision, below=of modelc] (satctheta) {$\text{SAT}(C_\theta)$};
  \node[action, below=of satctheta] (modelctheta) {$A_\theta:=\text{Model}(C_\theta)$\\
                                        	$\delta:=\Delta(A_\theta)$\\
                                        	$C:=C \cup \{\delta\}$\\
                                        	$D:=D \cup \{\delta\}$};
  \node[print, right=of satctheta] (noinv2) {No Invariant};
  \node[state, below=of noinv2] (end3) {END};
   
  \node[action, right=of satc] (cprime) {$C':=\mathcal C'(N, D, P)$};
  \node[decision, right=of cprime] (satcprime) {$\text{SAT}(C')$};
  \node[action, below=of satcprime] (inv) {$A_\theta:=\text{Model}(C')$\\
                                      	$I := \text{Inv}(N, D, P, A)$};
  \node[print, below=of inv] (printinv) {Invariant: $I$};
  \node[print, right=of satcprime] (noinv) {No Invariant};
  \node[state, below=of noinv] (end1) {END};
  \node[state, below=of printinv] (end2) {END};
 
  \draw (cprime) edge (satcprime);
  \draw (satcprime) edge node[above]{NO} (noinv);
  \draw (satcprime) edge node[right]{YES} (inv);
  \draw (inv) edge (printinv);
  \draw (noinv) edge (end1);
  \draw (printinv) edge (end2);
 
  \draw (begin) edge (c);
  \draw (c) edge coordinate[pos=.5] (edgein) (satc);
  \draw (satc) edge node[above]{NO} (cprime);
  \draw (satc) edge node[right]{YES} (modelc);
  \draw (modelc) edge (satctheta);
  \draw (satctheta) edge node[above]{NO} (noinv2);
  \draw (noinv2) edge (end3);
  \draw (satctheta) edge node[right]{YES} (modelctheta);
  \draw (modelctheta.south) -- ([yshift=-0.5cm] modelctheta.south)
  -| ([xshift=-2cm] modelctheta.west) |- (edgein);
\end{tikzpicture}

\fi

\end{document}
