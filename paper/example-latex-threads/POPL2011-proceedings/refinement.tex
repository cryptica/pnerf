\section{Abstraction refinement}
\label{sec-refinement}

\input{fig-alg-refine}
\input{fig-alg-mkHornClauses}
\input{fig-alg-mkTMHornClauses}
\input{fig-ex-cex-prog}

\paragraph{Procedure \algRefine}
In Figure~\ref{fig-alg-refine}, we present the procedure $\algRefine$
that takes as argument an error tuple and, if possible,
refines the abstraction functions to include predicates that witness
the fact that the error state is unreachable.
The procedure $\algRefine$ generates a set of Horn clauses
corresponding to the error tuple (lines~1--4).
Next, the \algRefine~algorithm invokes a solving procedure for Horn
clauses (lines~5--7).
Lastly, the procedure \algRefine updates the abstraction functions
using the solution of Horn clauses at lines 8--12.
We consider the solution $\Solution$ and add the atomic predicates
that appear in Sol(\unkOf{S}(\Vars) to the set of predicates
$\artPreds_i\ $. 
The index $i$ is chosen to be that of the thread where $S$ originated
from.
Similarly, the procedure updates the transition abstraction functions
at line~12.
Here, we only assume that \algSolveHornClauses returns a correct
solution to the set of Horn clauses received as argument.
In Section~\ref{sec-horn-solving}, we present a solving algorithm for
recursion-free Horn clauses over the linear arithmetic domain.

\paragraph{Function \algMkHornClauses} 
The generation of the Horn clauses is started from lines~1--4 of
Figure~\ref{fig-alg-refine}.
One clause requires that the solutions corresponding to the abstract
states from the error tuple do not intersect $\SymbError\ $:
$\set{\unkOf{S_1}(\Vars) \land \dots \land \unkOf{S_{\Num}}(\Vars)
  \land \SymbError \rightarrow \lfalse}\ $.
The other clauses are generated by invoking $\algMkHornClauses(S_i)$
for $i\in\ThreadIds\ $.
The function $\algMkHornClauses$ generates Horn clauses for
transitions considered during \aret computation as follows.
If the abstract state $\StateDst$ was produced by following a local
transition, i.e., $\artParent(\StateDst)=(\StateSrc,\rel)$ and
$\artParent(\rel)=\bot\ $, then one Horn clause corresponds to the
application of the local transition at line~12:
$\set{\unkOf{\StateSrc}(\Vars)\land \rel \rightarrow
  \unkOf{\StateDst}(\Vars')}\ $.
Additional Horn clauses are generated recursively for the parent
state $\StateSrc$ at line~5.
If the abstract state $\StateDst$ was produced by following an
environment transition, i.e., $\artParent(\StateDst)=(\StateSrc,\rel)$
and $\artParent(\rel)=(\StateOrig, \OrigRel)\ $, then two Horn clauses 
correspond to the generation of the environment transition (line~9)
and to the application of the environment transition (line~10).
Finally, if $\artParent(\StateDst)=\bot\ $, then one Horn clause 
constrains the solution of $\unkOf{\StateDst}(\Vars)$ at line~14:
$\set{\SymbInit \rightarrow\unkOf{\StateDst}(\Vars)}\ $.
Note that solutions for unknown states are expressed in terms of all
program variables $\Vars$, while solutions for unknown transitions are
expressed in terms of $\Vars$ and $\Vars'\ $.
Consequently, these solutions may lead to non-modular proofs even for
a set of Horn clauses that has modular solutions.


\paragraph{Discovery of  Modular Predicates}
We present modifications to our abstraction refinement algorithm that
guarantee the discovery of modular solutions whenever they exist.
With these modifications, solutions for unknown states originating in
thread $i$ can only be expressed in terms of $\GlobVars, \LocVarsOf{i}$
rather than the whole set of program variables $\Vars\ $.
Solutions for unknown transitions are restricted to the set of global
variables $\GlobVars, \GlobVars'\ $.
To implement these changes, we change line 1 from the \algRefine
procedure as follows:
%
\begin{center}
  \begin{minipage}[t]{.04\columnwidth}
    1
  \end{minipage}
  \begin{minipage}[t]{.94\columnwidth}
    \tabT $\HornClauses$ \algAssgn $\set{\unkOf{S_1}(\GlobVars, \LocVarsOf{1})\land \dots
    \land \unkOf{S_\Num}(\GlobVars, \LocVarsOf{\Num}) \land \SymbError}$
  \end{minipage}
\end{center}
% 
We also replace lines~9--14 from \algMkHornClauses with the
fragment shown in Figure~\ref{fig-alg-TMMkHornClauses}.
The rest of the function \algMkHornClauses is unchanged.
If the resulting Horn clauses have no solution, i.e.,
\algSolveHornClauses throws an \algUnsolvable exception, then it may
still be possible that a non-modular solution exists.
In this case, we invoke the abstraction refinement once again, this
time generating Horn clauses using the unmodified function
\algMkHornClauses from Figure~\ref{fig-alg-MkHornClauses}.


\paragraph{Example}
We illustrate the generation of Horn clauses using an expanded
version of $\TakeLockBit$ shown in Figure~\ref{fig-ex-cex-prog}.
This example contains an additional variable $\local$ local to the
first thread.
The initial symbolic state of the program $\SymbInit$ constrains both
$\local$ and $\lock$ to the value $0\ $. 
The transition relation of the first thread is extended with $\rel_0$,
which increments $\local$ by $1$ and assumes that the incremented value
is greater than or equal to $1\ $.
Similar to the example from Section~\ref{sec-illustration},
$\SymbError$ encodes the violation of the mutual exclusion property.
We show in Figure~\ref{fig-ex-cex}(a) the reachability trees as
computed by the \aret computation.
The error tuple consists of $m_4$ and $n_3\ $, i.e., $m_4
\land n_3 \land \SymbError$ is satisfiable.

From this error tuple, $\algMkHornClauses$ generates Horn clauses
following the procedure from Figure~\ref{fig-alg-MkHornClauses}.
These Horn clauses are shown in Figure~\ref{fig-ex-cex}(b).
The Horn clauses have unknown states 
$\unkOf{m_1}(\Vars)$, $\unkOf{m_2}(\Vars)$, $\unkOf{m_3}(\Vars)$, 
$\unkOf{m_4}(\Vars)$, $\unkOf{n_1}(\Vars)$, $\unkOf{n_2}(\Vars)\ $, and 
$\unkOf{n_3}(\Vars)\ $. 
The unknown transitions are $\unkOf{e_1}(\Vars,\Vars')$ and
$\unkOf{e_2}(\Vars,\Vars')\ $.

Comparatively, we show in Figure~\ref{fig-ex-cex}(c) the Horn clauses
generated with preference for modular solutions.
The solutions for the unknown states of thread 1 can refer only to
$(\GlobVars,\LocVarsOf{1})\ $, while the unknown states of thread 2
are restricted to $(\GlobVars,\LocVarsOf{1})\ $.
The unknown transitions are $\unkOf{e_1}(\GlobVars,\GlobVars')$ and
$\unkOf{e_2}(\GlobVars,\GlobVars')\ $.

\begin{theorem}[Progress of abstraction refinement]
\label{thm-refinement-progress}
%
The procedure \algRefine guarantees progress of abstraction
refinement, i.e., the same set of Horn clauses is never discovered
twice.\eofClaim
%
\end{theorem}
%
\iffalse
\includeProof{
\begin{proof} 
Let us consider an error tuple $(S_1, \dots, S_N)$ obtained
during \aret computation and let $\HornClauses$ be the set of Horn
clauses that are generated.
We assume here that the procedure \algSolveHornClauses returns a
solution that satisfies the generated Horn clauses. 
The predicates that appear in these solutions are added to
$\artPreds_i$ and $\artTPredsOf{i}{j}$ as in lines~8--12 of the
\algRefine procedure. 
Then, in the next \aret computation the abstract states will be at
least as precise as these solutions. 
Consequently, we can guarantees that, if abstract states corresponding
to $S_1, \dots, S_N$ are still reachable, then the error condition no
longer holds, i.e., $S_1 \land \dots S_N \land \SymbError$ is unsatisfiable.

Since each iteration of the loop from the \algMain function refines
the abstraction functions used in the previous iterations, we can
guarantee that all the previously discovered sets of Horn clauses remain
excluded in subsequent \aret computations.
\end{proof}
}
\fi

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
