*** REVIEW 1 ***



"The experiments provide some evidence of such tractability, but it's
not overwhelmingly convincing."

We are working on additional experiments.


"Basically, we want to prove that some binary relation over procedure
argument lists characterizes every recursive call that may be made in
the course of evaluating some original call."

We want to prove that a binary relation is a premise for the termination
argument presented in [19].


"(...) most of the experiment programs here either (a) work with
simple restriction to primitive recursion (like in Coq) or (b) use
int's as if they were naturals (...)"

The premise of a size change termination argument is a measure on the
size of parameters [15]. Consider the recursive program:

let rec upto i n = if i < n then upto (i + 1) n else ()

We cannot apply the size change termination argument for full
applications of upto. However, we can apply our approach to rove
termination of upto.


"These programs are trivially handled by (perhaps minor tweaks to)
techniques lightweight enough that they are already incorporated into
the type checkers of several production-quality functional language
implementations."

Which languages?


"The usual suspects of the Ackermann function and McCarthy's 91.
These are reasonable examples where fancy termination checking is
called for, though I question whether such reasoning is common enough
to deserve tool support."

The Ackermann and McCarthy91 functions illstrate the application of
our approach to common binary relations and code that is generally
regarded cumbersome. In the case of Ackermann, the binary relation
corresponds to a lexicographical order over the actual parameters. In
the case of McCarthy91, the binary relation corresponds to the ranking
\lambda n = max{0, 101 - n}.


"Fig. 3's Augment function is not total if argument expressions to "f"
may diverge.  Is that a problem?"

Our approach works under fairness assumptions. Thus, we assume that
the parameters terminate.




*** REVIEW 2 ***




"There is no comparison, for example, with recent
work like that of Alexander Krauss at TUM. Is there any connection
between the termination problem Krauss solves, or are they completely
separate."

TODO




*** REVIEW 3 ***



"I wonder: how easy would be it for DSolve to verify the kind 
of conditions generated by your reduction on larger programs?"

Given that we partially evaluate our products by beta-reduction,
we believe that the most important technical difficulty will be
providing auxiliary predicates to DSolve.


"An evaluation on a large, more "real-world" example would alleviate 
this concern."

We will gradly provide such examples in future work.


"If you had references and/or imperative features in your language,
would things change too much? "

Our notion of binary reachability and instrumentation technique would
not change much. The biggest limitation is the ability of the
reachability checker to handle imperative features.


"The paper would benefit from a discussion of the limitations of
the approach. Can you give some examples of programs that you were
NOT able to verify?"

Consider the following OCaml procedure:

let rec f g = if g () < 0 then 0 else f (fun () -> g () - 1);;

Our implementation cannot show this program terminating for all g's because:
   1) In the instrumentation, we cannot look at the closure corresponding to g.
   2) In the instrumentation, we do not want to apply g inside a
       transition invariant check, because g may modify the state of the
       program (e.g. may modify a reference).



