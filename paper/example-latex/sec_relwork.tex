\section{Related work}
\label{sec:relwork}

% \todo{TODO: WHAT THEY DO, WHAT WE CAN DO THAT THEY CAN, WHAT WE CAN DO
%   THAT IS AN IMPROVEMENT OVER THEM}


\newcommand{\oldRelWork}{false}
\ifthenelse{\equal{\oldRelWork}{true}}{

In this section we describe existing techniques for the
analysis and verification of functional programs.

\newcommand{\lfts}{\ensuremath{\tsf{LF}^\diamond}\xspace}
\paragraph{Resource bounds analysis.}

Hofmann et. al.~\cite{Hofmann11,Hofmann03} present type systems and
corresponding type inference algorithms for the analysis of
quantitative resource bounds.  The computed bounds are represented by
linear or polynomial expressions obtained by solving a linear
program based encoding of the type constraints.  The type system
keeps track of the resource consumption using an augmentation of type
judgements by resource counters.  These counters can be viewed as
monitor states that are embedded into type judgements.  In
contrast, our monitor states are embedded into the program.

The type inference algorithm of \cite{Hofmann11} can be used in combination
with our product construction to infer quantitative properties of
monitored programs. 
On the other hand, extending \cite{Hofmann11} to keep track of other
properties requires a redesign of the type system and the invention of
the corresponding inference algorithm.



\paragraph{Resource usage verification.}
The resource usage verification problem consists in checking that the
resource access traces generated by a program satisfy a
specification~\cite{Kobayashi09}.  Several works address the problem
of resource usage verification under different names,
e.g.~\cite{Terauchi02,Kobayashi05,Kobayashi09,Kobayashi11}.

Kobayashi~\cite{Kobayashi09} presents an algorithm for checking
properties given as finite state tree automata over a finite alphabet.
In constrast, we do not give a checking algorithm since we deal with
infinite state systems. Instead, we rely on the
reachability/termination tool \dsolve~\cite{Dsolve}. Our monitors can
check non-regular properties with the help of a
reachability/termination backend.

Foster~et.~al.~\cite{Terauchi02} presents a type inference system
for checking properties given as assume/assert program
annotations. Their annotations are over atomic predicates on program
values called \emph{type qualifiers}. Their type inference system is
similar to the liquid type inference system of \dsolve. In contrast to
our work, they can handle functional programs with references.

% addresses the resource usage verification
% problem for higher-order functional programs.
% % The resource usage
% % verification problem consists in verifying that the resource access
% % traces given by a program satisfy a specification. A specification is
% % a language of infinite words on a finite alphabet.
% Kobayashi gives a novel model checking technique for finite-state
% programs. Their technique applies a type checking approach to the
% model checking of higher-order recursion schemes corresponding to user
% programs. The technique is applied on $\omega$-regular safety
% properties. In contrast, our work enables reasoning about temporal
% properties of infinite-state programs using existing
% techniques. Combining their technique with approach is an interesting
% research goal.


% Our tool can verify the examples given in
% Section~3.1 of~\cite{Kobayashi09} (see experiments 15-18,43,44 in Figure~\ref{fig-experiments}) but we failed to verify the 2-place
% buffer in Example~6.1 of~\cite{Kobayashi09} because constructing the
% corresponding monitor specification requires ingenuity. Our work and
% Kobayashi's are different in that our we provide a framework for
% expressing temporal properties that can be verified with existing
% tools and Kobayashi developed a full verification framework.
 
% Kobayashi \cite{Kobayashi09} applied HORS as an abstract model of
% higher order functional programs. Kobayashi presented a type based
% algorithm for checking that HORS satisfy finite state machine-based
% specifications. There are two main differences to our work. First, we
% target \ocaml\ programs, while Kobayashi's considers a prototype
% functional language. Second, we deal with properties represented by
% infinite state monitors.


\paragraph{Contract checking.}

Contracts are pre- and post-condition specifications for
functions. Xu created a verification tool \cite{DanaPhd} for Haskell that is
based on contracts and partial evaluation. 
Pre- and post-conditions can only refer to the program execution
before and after procedure calls. In contrast, our monitor
specifications have the ability of observing program executions at all times.

\paragraph{Liquid typing.}

\dsolve\ \cite{Dsolve} is a reachability checker based on refinement
type inference.  The type inference algorithm consists of two
parts. First, a set of constraints over refinement predicates is
generated from program code. Second, an iterative algorithm tests
candidate solutions constructed from a set of predicate schemes in the
theory of linear arithmetic and uninterpreted functions. While \dsolve\
is effective for the verification of assertion validity, our product
construction allows \dsolve\ to verify arbitrary safety properties.



}{

\paragraph{Termination and control-flow analysis}

Traditionally, termination analysis of higher-order programs is
developed on top of a control-flow
analysis~\cite{Sereni05terminationanalysis,SereniAPLAS05,SereniICFP07}.
Our approach relies on the applied safety checker to keep track of
control flow. 
In principle, our transformation could benefit from the results of
control-flow analysis, as discussed in Section~\ref{sec:conclusion}. 
Practically, such additional information was not necessary when
proving termination of all examples presented
in~\cite{Sereni05terminationanalysis,SereniAPLAS05,SereniICFP07}.
Adding a control-flow analysis
pass~\cite{Shivers88,MightJFP08,MightPOPL11,MightSCHEME2010} before the transformation
would be akin to the application of (function) pointer analysis for
imperative programs. 
We leave a study of such an integration as future work.

  \paragraph{Abstraction for termination.} The size change termination
  argument~\cite{SCTPOPL2001} can be extended to higher-order functional
  programs, see e.g.~\cite{JonesBohr04,SereniAPLAS05}. This argument requires checking the presence of an
  infinite descent in values passed to application sites of the program
  on any infinite traversal of the call graph. In contrast, our
  approach can keep track of a rank descent in arbitrary expressions
  over program values.
  In principle, SCT can be seen a specific abstract domain that yields
  termination arguments related to disjunctive
  well-foundedness~\cite{PodelskiSAS10}.
  We leave the question if general abstraction techniques for
termination~\cite{CousotHigherOrder94,CousotPOPL12} can be reduced by
an appropriate source to source transformation as furture work.


\paragraph{Contract checking.}

Contracts are pre- and post-condition specifications for functions. Xu
created a verification tool \cite{DanaPhd} for Haskell that is based
on contracts and partial evaluation.  Their approach works well for
checking safety properties, and can even detect divergence of
programs. In contrast, our approach is specialized to the verification
of termination, and is a step towards the automated verification of
termination through counterexample guided abstraction refinement.

\paragraph{Liquid typing.}

\dsolve\ \cite{Dsolve} is a reachability checker based on refinement
type inference.  The type inference algorithm consists of two
parts. First, a set of constraints over refinement predicates is
generated from program code. Second, an iterative algorithm tests
candidate solutions constructed from a set of predicate schemes in the
theory of linear arithmetic and uninterpreted functions. As our
experiments show, the composition of our transformation and \dsolve\ 
yields a binary reachability analysis tool.

}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
